<!DOCTYPE html>
<html class="h-100" data-bs-theme="dark">
  <head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <style>
      code {
        white-space: pre;
        word-break: normal;
        word-wrap: normal;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <title> Главная страница </title>
  </head>
  <body class="d-flex flex-column h-100 bg-secondary.bg-gradient">
    <div class="navbar flex-column bg-secondary-subtle justify-content-center">
      <h1><a href="./index_bs.html#">Язык Rust</a></h1>
    </div>
    <div class="container-sm py-3 flex-grow-1">
      <div class="row gx-3 h-100">
        <div class="col col-3 flex-grow-1">
          <div class="rounded bg-secondary-subtle p-3 h-100">
            <h2 id="there_be_links" class="center"><a href="#there_be_links">Главы</a></h2>
            <ol>
              <li><a href="./index_bs.html#intro">Введение</a></li>
              <li><a href="./index_bs.html#borrowing">Владение</a></li>
              <li><a href="./index_bs.html#enums">Перечисления</a></li>
              <li><a href="./index_bs.html#matching">Управляющая конструкция match</a></li>
              <li><a href="./index_bs.html#crates">Пакеты, крейты и модули</a></li>
              <li><a href="./index_bs.html#result">Обработка ошибок</a></li>
            </ol>
          </div>
        </div>

        <div class="col col-9 flex-grow-1">
          <div class="p-3 rounded bg-secondary-subtle h-100">
            <h1 id="intro">Введение</h1>
              <a href="https://doc.rust-lang.ru/book/" style="float:right"><img src="./krab2.svg" width=80></a>
              <p>Добро пожаловать в <a href="https://doc.rust-lang.ru/book/">The Rust Programming Language</a>, вводную книгу о Rust. Язык программирования Rust помогает создавать быстрые, более надёжные приложения. Хорошая эргономика и низкоуровневый контроль часто являются противоречивыми требованиями для дизайна языков программирования; Rust бросает вызов этому конфликту. Благодаря сбалансированности мощных технических возможностей c большим удобством разработки, Rust предоставляет возможности управления низкоуровневыми элементами (например, использование памяти) без трудностей, традиционно связанных с таким контролем.</p>

              <h1>Кому подходит Rust</h1>
              <p>Rust идеально подходит для многих людей по целому ряду причин. Давайте рассмотрим несколько наиболее важных групп.</p>

              <h1>Команды разработчиков</h1>
              <p>Rust зарекомендовал себя как продуктивный инструмент для совместной работы больших команд разработчиков с разным уровнем знаний в области системного программирования. Низкоуровневый код подвержен различным трудноуловимым ошибкам, которые в большинстве других языков могут быть обнаружены только с помощью тщательного тестирования и проверки кода опытными разработчиками. В Rust компилятор играет роль привратника, отказываясь компилировать код с этими неуловимыми ошибками, включая ошибки параллелизма. Работая вместе с компилятором, команда может сфокусироваться на работе над логикой программы, а не над поиском ошибок.</p></p>

              <p>Rust также привносит современные инструменты разработчика в мир системного программирования:</p>

              <ul>
                <li>Cargo, входящий в комплект менеджер зависимостей и инструмент сборки, делает добавление, компиляцию и управление зависимостями безболезненным и согласованным в рамках всей экосистемы Rust.</li>
                <li>Инструмент форматирования Rustfmt обеспечивает единый стиль кодирования для всех разработчиков.</li>
                <li>Rust Language Server обеспечивает интеграцию с интегрированной средой разработки (IDE) для автодополнения кода и встроенных сообщений об ошибках.</li>
              </ul>
              <p>Благодаря применению этих и других инструментов в экосистеме Rust разработчики способны продуктивно работать при написании кода системного уровня.</p>

              <h1>Студенты</h1>
              <p>Rust полезен для студентов и тех, кто заинтересован в изучении системных концепций. Используя Rust, многие люди узнали о таких темах, как разработка операционных систем. Сообщество радушно и с удовольствием ответит на вопросы начинающих. Благодаря усилиям — таким, как эта книга — команды Rust хотят сделать концепции систем более доступными для большего числа людей, особенно для новичков в программировании.</p>

              <h1>Компании</h1>
              <p>Сотни больших и малых компаний используют Rust в промышленных условиях для решения различных задач, включая инструменты командной строки, веб-сервисы, инструменты DevOps, встраиваемые устройства, анализ и транскодирование аудио и видео, криптовалюты, биоинформатику, поисковые системы, приложения Интернета вещей, машинное обучение и даже основные части веб-браузера Firefox.</p>

              <h1>Разработчики Open Source</h1>
              <p>Rust предназначен для людей, которые хотят развивать язык программирования Rust, сообщество, инструменты для разработчиков и библиотеки. Мы будем рады, если вы внесёте свой вклад в развитие языка Rust.</p>

              <h1>Люди, ценящие скорость и стабильность</h1>
              <a href="https://doc.rust-lang.ru/book/" style="float:left"><img src="./krab3.svg" width=80></a>
              <p>Rust предназначен для любителей скорости и стабильности в языке. Под скоростью мы подразумеваем как быстродействие программы на Rust, так и быстроту, с которой Rust позволяет писать программы. Проверки компилятора Rust обеспечивают стабильность за счёт функциональных дополнений и рефакторинга. Это выгодно отличается от хрупкого унаследованного кода в языках без таких проверок, который разработчики часто боятся изменять. Благодаря обеспечению абстракций с нулевой стоимостью, высокоуровневых возможностей, компилируемых в низкоуровневый код такой же быстрый, как и написанный вручную, Rust стремится сделать безопасный код ещё и быстрым.</p>

              <p>Язык Rust надеется поддержать и многих других пользователей; перечисленные здесь - лишь самые значимые заинтересованные лица. В целом, главная цель Rust - избавиться от компромиссов, на которые программисты шли десятилетиями, обеспечив безопасность и производительность, скорость и эргономичность. Попробуйте Rust и убедитесь, подойдут ли вам его решения.</p>


              <br><hr><br>
              <h1 id="borrowing">Владение</h1>
              <p>Владение - это самая уникальная особенность Rust, которая имеет глубокие последствия для всего языка. Это позволяет Rust обеспечивать безопасность памяти без использования сборщика мусора, поэтому важно понимать, как работает владение. В этой главе мы поговорим о владении, а также о нескольких связанных с ним возможностях: заимствовании, срезах и о том, как Rust раскладывает данные в памяти.</p>

              <h2>Что такое владение?</h2>
              <p>Владение — это набор правил, определяющих, как программа на языке Rust управляет памятью. Все программы так или иначе должны управлять тем, как они используют память компьютера во время работы. Некоторые языки имеют сборщик мусора, регулярно отслеживающий неиспользуемую память во время работы программы; в других языках программист должен явно выделять и освобождать память. В Rust используется третий подход: память управляется через систему владения с набором правил, которые проверяются компилятором. При нарушении любого из правил программа не будет скомпилирована. Ни одна из особенностей системы владения не замедлит работу вашей программы.</p>

              <p>Поскольку владение является новой концепцией для многих программистов, требуется некоторое время, чтобы привыкнуть к ней. Хорошая новость заключается в том, что чем больше у вас будет опыта с Rust и с правилами системы владения, тем легче вам будет естественным образом разрабатывать безопасный и эффективный код. Держитесь! Не сдавайтесь!</p>

              <p>Понимание концепции владения даст вам основу для понимания всех остальных особенностей, делающих Rust уникальным. В этой главе вы изучите владение на примерах, которые сфокусированы на наиболее часто используемой структуре данных: строках.</p>

              <h2>Правила владения</h2>
              <p>Во-первых, давайте взглянем на правила владения. Помните об этих правилах, пока мы работаем с примерами, которые их иллюстрируют:</p>

              <ul>
                <li>У каждого значения в Rust есть владелец,</li>
                <li>У значения может быть только один владелец в один момент времени,</li>
                <li>Когда владелец покидает область видимости, значение удаляется.</li>
              </ul>


              <br><hr><br>
              <h1 id="enums">Определение перечисления</h1>
              <p>Там, где структуры дают вам возможность группировать связанные поля и данные, например Rectangle с его width и height, перечисления дают вам способ сказать, что значение является одним из возможных наборов значений. Например, мы можем захотеть сказать, что Rectangle — это одна из множества возможных фигур, в которую также входят Circle и Triangle. Для этого Rust позволяет нам закодировать эти возможности в виде перечисления.</p>

              <p>Давайте рассмотрим ситуацию, которую мы могли бы захотеть отразить в коде, и поймём, почему перечисления полезны и более уместны, чем структуры в этом случае. Допустим, нам нужно работать с IP-адресами. В настоящее время для обозначения IP-адресов используются два основных стандарта: четвёртая и шестая версии. Поскольку это единственно возможные варианты IP-адресов, с которыми может столкнуться наша программа, мы можем перечислить все возможные варианты, откуда перечисление и получило своё название.</p>

              <p>Любой IP-адрес может быть либо четвёртой, либо шестой версии, но не обеими одновременно. Эта особенность IP-адресов делает структуру данных enum подходящей, поскольку значение enum может представлять собой только один из его возможных вариантов. Адреса как четвёртой, так и шестой версии по своей сути все равно являются IP-адресами, поэтому их следует рассматривать как один и тот же тип, когда в коде обрабатываются задачи, относящиеся к любому типу IP-адресов.</p>

              <p>Можно выразить эту концепцию в коде, определив перечисление IpAddrKind и составив список возможных видов IP-адресов, V4 и V6. Вот варианты перечислений:</p>


              <code>
                enum IpAddrKind {
                    V4,
                    V6,
                }
              </code>
              <p>IpAddrKind теперь является пользовательским типом данных, который мы можем использовать в другом месте нашего кода.</p>

              <h3>Значения перечислений</h3>
              <p>Экземпляры каждого варианта перечисления IpAddrKind можно создать следующим образом:</p>


              <code>
                let four = IpAddrKind::V4;
                let six = IpAddrKind::V6;
              </code>
              <p>Обратите внимание, что варианты перечисления находятся в пространстве имён вместе с его идентификатором, а для их обособления мы используем двойное двоеточие. Это удобно тем, что теперь оба значения IpAddrKind::V4 и IpAddrKind::V6 относятся к одному типу: IpAddrKind. Затем мы можем, например, определить функцию, которая принимает любой из вариантов IpAddrKind:</p>


              <code>
                fn route(ip_kind: IpAddrKind) {}
              </code>

              <p>Можно вызвать эту функцию с любым из вариантов:</p>

              <code>
                route(IpAddrKind::V4);
                route(IpAddrKind::V6);
              </code>

              <p>Использование перечислений позволяет получить ещё больше преимуществ. Если подумать о нашем типе для IP-адреса, то выяснится, что на данный момент у нас нет возможности хранить собственно сам IP-адрес; мы будем знать только его тип. Учитывая, что недавно в главе 5 вы узнали о структурах, у вас может возникнуть соблазн решить эту проблему с помощью структур, как показано в листинге 6-1.</p>


              <code>
                enum IpAddrKind {
                    V4,
                    V6,
                }

                struct IpAddr {
                    kind: IpAddrKind,
                    address: String,
                }

                let home = IpAddr {
                    kind: IpAddrKind::V4,
                    address: String::from("127.0.0.1"),
                };

                let loopback = IpAddr {
                    kind: IpAddrKind::V6,
                    address: String::from("::1"),
                };
              </code>
              <p>Листинг 6-1. Сохранение данных и IpAddrKind IP-адреса с использованием struct</p>

              <p>Здесь мы определили структуру IpAddr, у которой есть два поля: kind типа IpAddrKind (перечисление, которое мы определили ранее) и address типа String. У нас есть два экземпляра этой структуры. Первый - home, который является IpAddrKind::V4 в качестве значения kind с соответствующим адресом 127.0.0.1. Второй экземпляр - loopback. Он в качестве значения kind имеет другой вариант IpAddrKind, V6, и с ним ассоциирован адрес ::1. Мы использовали структуру для объединения значений kind и address вместе, таким образом тип формата адреса теперь ассоциирован со значением.</p>

              <p>Однако представление этой же концепции с помощью перечисления более лаконично: вместо того, чтобы помещать перечисление в структуру, мы можем поместить данные непосредственно в любой из вариантов перечисления. Это новое определение перечисления IpAddr гласит, что оба варианта V4 и V6 будут иметь соответствующие значения String:</p>


              <code>
                enum IpAddr {
                    V4(String),
                    V6(String),
                }

                let home = IpAddr::V4(String::from("127.0.0.1"));

                let loopback = IpAddr::V6(String::from("::1"));
              </code>
              <p>Мы прикрепляем данные к каждому варианту перечисления напрямую, поэтому нет необходимости в дополнительной структуре. Здесь также легче увидеть ещё одну деталь того, как работают перечисления: имя каждого варианта перечисления, который мы определяем, также становится функцией, которая создаёт экземпляр перечисления. То есть IpAddr::V4() - это вызов функции, который принимает String и возвращает экземпляр типа IpAddr. Мы автоматически получаем эту функцию-конструктор, определяемую в результате определения перечисления.</p>

              <p>Ещё одно преимущество использования перечисления вместо структуры заключается в том, что каждый вариант перечисления может иметь разное количество ассоциированных данных представленных в разных типах. Версия 4 для IP адресов всегда будет содержать четыре цифровых компонента, которые будут иметь значения между 0 и 255. При необходимости сохранить адреса типа V4 как четыре значения типа u8, а также описать адреса типа V6 как единственное значение типа String, мы не смогли бы с помощью структуры. Перечисления решают эту задачу легко:</p>


              <code>
                enum IpAddr {
                    V4(u8, u8, u8, u8),
                    V6(String),
                }

                let home = IpAddr::V4(127, 0, 0, 1);

                let loopback = IpAddr::V6(String::from("::1"));
              </code>

              <p>Мы показали несколько различных способов определения структур данных для хранения IP-адресов четвёртой и шестой версий. Однако, как оказалось, желание хранить IP-адреса и указывать их тип настолько распространено, что в стандартной библиотеке есть определение, которое мы можем использовать! Давайте посмотрим, как стандартная библиотека определяет IpAddr: в ней есть точно такое же перечисление с вариантами, которое мы определили и использовали, но она помещает данные об адресе внутрь этих вариантов в виде двух различных структур, которые имеют различные определения для каждого из вариантов:</p>



              <code>
                struct Ipv4Addr {
                    // --snip--
                }

                struct Ipv6Addr {
                    // --snip--
                }

                enum IpAddr {
                    V4(Ipv4Addr),
                    V6(Ipv6Addr),
                }
              </code>

              <p>Этот код иллюстрирует что мы можем добавлять любой тип данных в значение перечисления: строку, число, структуру и пр. Вы даже можете включить в перечисление другие перечисления! Стандартные типы данных не очень сложны, хотя, потенциально, могут быть очень сложными (вложенность данных может быть очень глубокой).</p>

              <p>Обратите внимание, что хотя определение перечисления IpAddr есть в стандартной библиотеке, мы смогли объявлять и использовать свою собственную реализацию с аналогичным названием без каких-либо конфликтов, потому что мы не добавили определение стандартной библиотеки в область видимости кода. Подробнее об этом поговорим в Главе 7.</p>

              <p>Рассмотрим другой пример перечисления в листинге 6-2: в этом примере каждый элемент перечисления имеет свой особый тип данных внутри:</p>


              <code>
                enum Message {
                    Quit,
                    Move { x: i32, y: i32 },
                    Write(String),
                    ChangeColor(i32, i32, i32),
                }
              </code>

              <p>Листинг 6-2. Перечисление Message, в каждом из вариантов которого хранятся разные количества и типы значений.</p>

              <p>Это перечисление имеет 4 элемента:</p>

              <p>Quit - пустой элемент без ассоциированных данных,</p>
              <p>Move имеет именованные поля, как и структура.</p>
              <p>Write - элемент с единственной строкой типа String,</p>
              <p>ChangeColor - кортеж из трёх значений типа i32.</p>
              <p>Определение перечисления с вариантами, такими как в листинге 6-2, похоже на определение значений различных типов внутри структур, за исключением того, что перечисление не использует ключевое слово struct и все варианты сгруппированы внутри типа Message. Следующие структуры могут содержать те же данные, что и предыдущие варианты перечислений:</p>


              <code>
                struct QuitMessage; // unit struct
                struct MoveMessage {
                    x: i32,
                    y: i32,
                }
                struct WriteMessage(String); // tuple struct
                struct ChangeColorMessage(i32, i32, i32); // tuple struct
              </code>

              <p>Но когда мы использовали различные структуры, каждая из которых имеет свои собственные типы, мы не могли легко определять функции, которые принимают любые типы сообщений, как это можно сделать с помощью перечисления типа Message, объявленного в листинге 6-2, который является единым типом.</p>

              <p>Есть ещё одно сходство между перечислениями и структурами: так же, как мы можем определять методы для структур с помощью impl блока, мы можем определять и методы для перечисления. Вот пример метода с именем call, который мы могли бы определить в нашем перечислении Message:</p>


              <code>
                impl Message {
                    fn call(&self) {
                        // method body would be defined here
                    }
                }

                let m = Message::Write(String::from("hello"));
                m.call();
              </code>
              <p>В теле метода будет использоваться self для получения значение того объекта, у которого мы вызвали этот метод. В этом примере мы создали переменную m, содержащую значение Message::Write(String::from("hello")), и именно это значение будет представлять self в теле метода call при выполнении m.call().</p>

              <p>Теперь посмотрим на другое наиболее часто используемое перечисление из стандартной библиотеки, которое является очень распространённым и полезным: Option.</p>

              <h3>Перечисление Option и его преимущества перед Null-значениями</h3>
              <p>В этом разделе рассматривается пример использования Option, ещё одного перечисления, определённого в стандартной библиотеке. Тип Option кодирует очень распространённый сценарий, в котором значение может быть чем-то, а может быть ничем.</p>

              <p>Например, если вы запросите первый элемент из непустого списка, вы получите значение. Если вы запросите первый элемент пустого списка, вы ничего не получите. Выражение этой концепции в терминах системы типов означает, что компилятор может проверить, обработали ли вы все случаи, которые должны были обработать; эта функциональность может предотвратить ошибки, которые чрезвычайно распространены в других языках программирования.</p>

              <p>Дизайн языка программирования часто рассматривается с точки зрения того, какие функции вы включаете в него, но те функции, которые вы исключаете, также важны. Например в Rust нет такого функционала как null значения, однако он есть во многих других языках. Null значение - это значение, которое означает, что значения нет. В языках с null значением переменные всегда могут находиться в одном из двух состояний: нет значения (null) или есть значение (not-null).</p>

              <p>В своей презентации 2009 года «Null ссылки: ошибка в миллиард долларов» Тони Хоар (Tony Hoare), изобретатель null, сказал следующее:</p>

              <p>Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую комплексную систему типов для ссылок на объектно-ориентированном языке. Моя цель состояла в том, чтобы гарантировать, что любое использование ссылок должно быть абсолютно безопасным, с автоматической проверкой компилятором. Но я не мог устоять перед соблазном вставить пустую ссылку просто потому, что это было так легко реализовать. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили боль и ущерб на миллиард долларов за последние сорок лет.</p>

              <p>Проблема с null значениями заключается в том, что если вы попытаетесь использовать null значение в качестве not-null значения, вы получите ошибку определённого рода. Поскольку свойство null или not-null распространено повсеместно, сделать такую ошибку очень просто.</p>

              <p>Тем не менее, концепция, которую null пытается выразить, является полезной: null - это значение, которое в настоящее время по какой-то причине недействительно или отсутствует.</p>

              <p>Проблема на самом деле не в концепции, а в конкретной реализации. Таким образом, в Rust нет значений null, но есть перечисление, которое может закодировать концепцию присутствия или отсутствия значения. Это перечисление Option&lt;T&gt; , и оно определено стандартной библиотекой следующим образом:</p>



              <code>
                enum Option&lt;T&gt; {
                    None,
                    Some(T),
                }
              </code>

              <p>Перечисление Option&lt;T&gt; настолько полезно, что оно даже включено в прелюдию; вам не нужно явно вводить его в область видимости. Его варианты также включены в прелюдию: вы можете использовать Some и None напрямую, без префикса Option::. При всём при этом, Option&lt;T&gt; является обычным перечислением, а Some(T) и None представляют собой его варианты.</p>

              <p>&lt;T&gt; - это особенность Rust, о которой мы ещё не говорили. Это параметр обобщённого типа, и мы рассмотрим его более подробно в главе 10. На данный момент всё, что вам нужно знать, это то, что &lt;T&gt; означает, что вариант Some Option может содержать один фрагмент данных любого типа, и что каждый конкретный тип, который используется вместо T делает общий Option&lt;T&gt; другим типом. Вот несколько примеров использования Option для хранения числовых и строковых типов:</p>


              <code>
                let some_number = Some(5);
                let some_char = Some('e');

                let absent_number: Option&lt;i32&gt; = None;
              </code>

              <p>Тип some_number - Option&lt;i32&gt;. Тип some_char - Option&lt;char&gt;, это другой тип. Rust может вывести эти типы, потому что мы указали значение внутри варианта Some. Для absent_number Rust требует, чтобы мы аннотировали общий тип для Option: компилятор не может вывести тип, который будет в Some, глядя только на значение None. Здесь мы сообщаем Rust, что absent_number должен иметь тип Option&lt;i32&gt;.<p>

              <p>Когда есть значение Some, мы знаем, что значение присутствует и содержится внутри Some. Когда есть значение None, это означает то же самое, что и null в некотором смысле: у нас нет действительного значения. Так почему наличие Option&lt;T&gt; лучше, чем null?</p>

              <p>Вкратце, поскольку Option&lt;T&gt; и T (где T может быть любым типом) относятся к разным типам, компилятор не позволит нам использовать значение Option&lt;T&gt; даже если бы оно было определённо допустимым значением. Например, этот код не будет компилироваться, потому что он пытается добавить i8 к значению типа Option&lt;i8&gt;:</p>

              <code>
                let x: i8 = 5;
                let y: Option&lt;i8&gt; = Some(5);

                let sum = x + y;
              </code>


              <p>Если мы запустим этот код, то получим такое сообщение об ошибке:</p>


              <code>
                $ cargo run
                  Compiling enums v0.1.0 (file:///projects/enums)
                error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
                --&gt; src/main.rs:5:17
                  |
                5 |     let sum = x + y;
                  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
                  |
                  = help: the trait `Add&lt;Opiton&lt;i8&gt;&gt;` is not implemented for `i8`
                  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
                            &lt;&'a i8 as Add&lt;i8&gt;&gt;
                            &lt;&i8 as Add&lt;&i8&gt;&gt;
                            &lt;i8 as Add&lt;&i8&gt;&gt;
                            &lt;i8 as Add&gt;
              </code>

              <p>For more information about this error, try `rustc --explain E0277`.</p>
              error: could not compile `enums` due to previous error
              <p>Сильно! Фактически, это сообщение об ошибке означает, что Rust не понимает, как сложить i8 и Option&gt;i8>, потому что это разные типы. Когда у нас есть значение типа наподобие i8, компилятор гарантирует, что у нас всегда есть допустимое значение типа. Мы можем уверенно продолжать работу, не проверяя его на null перед использованием. Однако, когда у нас есть значение типа Option&gt;T&lt; (где T - это любое значение любого типа T, упакованное в Option, например значение типа i8 или String), мы должны беспокоиться о том, что значение типа T возможно не имеет значения (является вариантом None), и компилятор позаботится о том, чтобы мы обработали такой случай, прежде чем мы бы попытались использовать None значение.</p>

                <p>Другими словами, вы должны преобразовать Option&lt;T&gt; в T прежде чем вы сможете выполнять операции с этим T. Как правило, это помогает выявить одну из наиболее распространённых проблем с null: предполагая, что что-то не равно null, когда оно на самом деле равно null.</p>

              <p>Устранение риска ошибочного предположения касательно не-null значения помогает вам быть более уверенным в своём коде. Чтобы иметь значение, которое может быть null, вы должны явно описать тип этого значения с помощью Option&lt;T&gt;. Затем, когда вы используете это значение, вы обязаны явно обрабатывать случай, когда значение равно null. Везде, где значение имеет тип, отличный от Option&lt;T&gt;, вы можете смело рассчитывать на то, что значение не равно null. Это продуманное проектное решение в Rust, ограничивающее распространение null и увеличивающее безопасность кода на Rust.</p>

              <p>Итак, как же получить значение T из варианта Some, если у вас на руках есть только объект Option&lt;T&gt;, и как можно его, вообще, использовать? Перечисление Option&lt;T&gt; имеет большое количество методов, полезных в различных ситуациях; вы можете ознакомиться с ними в его документации. Знакомство с методами перечисления Option&lt;T&gt; будет чрезвычайно полезным в вашем путешествии с Rust.</p>

              <p>В общем случае, чтобы использовать значение Option&lt;T&gt;, нужен код, который будет обрабатывать все варианты перечисления Option&lt;T&gt;. Вам понадобится некоторый код, который будет работать только тогда, когда у вас есть значение Some(T), и этому коду разрешено использовать внутри T. Также вам понадобится другой код, который будет работать, если у вас есть значение None, и у этого кода не будет доступного значения T. Выражение match — это конструкция управления потоком выполнения программы, которая делает именно это при работе с перечислениями: она запускает разный код в зависимости от того, какой вариант перечисления имеется, и этот код может использовать данные, находящиеся внутри совпавшего варианта.</p>






              <br><hr><br>
              <h1 id="matching">Управляющая конструкция match</h1>
              <p>В Rust есть чрезвычайно мощный механизм управления потоком, именуемый match, который позволяет сравнивать значение с различными шаблонами и затем выполнять код в зависимости от того, какой из шаблонов совпал. Шаблоны могут состоять из литеральных значений, имён переменных, подстановочных знаков и многого другого; в главе 18 рассматриваются все различные виды шаблонов и то, что они делают. Сила match заключается в выразительности шаблонов и в том, что компилятор проверяет, что все возможные случаи обработаны.</p>

              <p>Думайте о выражении match как о машине для сортировки монет: монеты скользят по дорожке с различными по размеру отверстиями, и каждая монета падает через первое попавшееся отверстие, в которое она поместилась. Таким же образом значения проходят через каждый шаблон в match, и при первом же "подходящем" шаблоне значение попадает в соответствующий блок кода, который будет использоваться во время выполнения.</p>

              <p>Говоря о монетах, давайте используем их в качестве примера, используя match! Для этого мы напишем функцию, которая будет получать на вход неизвестную монету Соединённых Штатов и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах, как показано в листинге 6-3.</p>


              <code>
                enum Coin {
                    Penny,
                    Nickel,
                    Dime,
                    Quarter,
                }

                fn value_in_cents(coin: Coin) -&gt; u8 {
                    match coin {
                        Coin::Penny =&gt; 1,
                        Coin::Nickel =&gt; 5,
                        Coin::Dime =&gt; 10,
                        Coin::Quarter =&gt; 25,
                    }
                }
              </code>
              <p>Листинг 6-3: Перечисление и выражение match, использующее в качестве шаблонов его варианты</p>

              <p>Давайте разберём match в функции value_in_cents. Сначала пишется ключевое слово match, затем следует выражение, которое в данном случае является значением coin. Это выглядит очень похоже на условное выражение, используемое в if, но есть большая разница: с if выражение должно возвращать булево значение, а здесь это может быть любой тип. Тип coin в этом примере — перечисление типа Coin, объявленное в строке 1.</p>

              <p>Далее идут ветки match. Ветки состоят из двух частей: шаблон и некоторый код. Здесь первая ветка имеет шаблон, который является значением Coin::Penny, затем идёт оператор =&gt;, который разделяет шаблон и код для выполнения. Код в этом случае - это просто значение 1. Каждая ветка отделяется от последующей при помощи запятой.</p>

              <p>Когда выполняется выражение match, оно сравнивает полученное значение с образцом каждого ответвления по порядку. Если образец совпадает со значением, то выполняется код, связанный с этим образцом. Если этот образец не соответствует значению, то выполнение продолжается со следующей ветки, так же, как в автомате по сортировке монет. У нас может быть столько ответвлений, сколько нужно: в листинге 6-3 наш match состоит из четырёх ответвлений.</p>

              <p>Код, связанный с каждым ответвлением, является выражением, а полученное значение выражения в соответствующем ответвлении — это значение, которое возвращается для всего выражения match.</p>

              <p>Обычно фигурные скобки не используются, если код совпадающей ветви невелик, как в листинге 6-3, где каждая ветвь просто возвращает значение. Если вы хотите выполнить несколько строк кода в одной ветви, вы должны использовать фигурные скобки, а запятая после этой ветви необязательна. Например, следующий код печатает "Lucky penny!" каждый раз, когда метод вызывается с Coin::Penny, но при этом он возвращает последнее значение блока - 1:</p>

              <code>
                fn value_in_cents(coin: Coin) -&gt; u8 {
                    match coin {
                        Coin::Penny =&gt; {
                            println!("Lucky penny!");
                            1
                        }
                        Coin::Nickel =&gt; 5,
                        Coin::Dime =&gt; 10,
                        Coin::Quarter =&gt; 25,
                    }
                }
              </code>







              <br><hr><br>
              <h1 id="crates">Управление растущими проектами с помощью пакетов, крейтов и модулей</h1>
              <p>По мере роста кодовой базы ваших программ, организация проекта будет иметь большое значение, ведь отслеживание всей программы в голове будет становиться всё более сложным. Группируя связанные функции и разделяя код по основным функциональностям (фичам, feature), вы делаете более прозрачным понимание о том, где искать код реализующий определённую функцию и где стоит вносить изменения для того чтобы изменить её поведение.</p>

              <p>Программы, которые мы писали до сих пор, были в одном файле одного модуля. По мере роста проекта, мы можем организовывать код иначе, разделив его на несколько модулей и несколько файлов. Пакет может содержать несколько бинарных крейтов и опционально один крейт библиотеки. Пакет может включать в себя много бинарных крейтов и опционально один библиотечный крейт. По мере роста пакета вы можете извлекать части программы в отдельные крейты, которые затем станут внешними зависимостями для основного кода нашей программы. Эта глава охватывает все эти техники. В свою очередь для очень крупных проектов, состоящих из набора взаимосвязанных пакетов развивающихся вместе, Cargo предоставляет рабочие пространства, workspaces, их мы рассмотрим за пределами данной главы, в разделе "Рабочие пространства Cargo" Главы 14.</p>

              <p>Мы также обсудим инкапсуляцию деталей, которая позволяет использовать код снова на более высоком уровне: единожды реализовав какую-то операцию, другой код может вызывать этот код через публичный интерфейс, не зная как работает реализация. То, как вы пишете код, определяет какие части общедоступны для использования другим кодом и какие части являются закрытыми деталями реализации для которых вы оставляете право на изменения только за собой. Это ещё один способ ограничить количество деталей, которые вы должны держать в голове.</p>

              <p>Связанное понятие - это область видимости: вложенный контекст в котором написан код имеющий набор имён, которые определены «в текущей области видимости». При чтении, письме и компиляции кода, программистам и компиляторам необходимо знать, относится ли конкретное имя в определённом месте к переменной, к функции, к структуре, к перечислению, к модулю, к константе или другому элементу и что означает этот элемент. Можно создавать области видимости и изменять какие имена входят или выходят за их рамки. Нельзя иметь два элемента с тем же именем в одной области; есть доступные инструменты для разрешения конфликтов имён.</p>

              <p>Rust имеет ряд функций, которые позволяют управлять организацией кода, в том числе управлять тем какие детали открыты, какие детали являются частными, какие имена есть в каждой области вашей программы. Эти функции иногда вместе именуемые модульной системой включают в себя:</p>

              <ul>
                <li><b>Пакеты:</b> Функционал Cargo позволяющий собирать, тестировать и делиться крейтами</li>
                <li><b>Крейты:</b> Дерево модулей, которое создаёт библиотечный или исполняемый файл</li>
                <li><b>Модули и use:</b> Позволяют вместе контролировать организацию, область видимости и скрытие путей</li>
                <li><b>Пути:</b> способ именования элемента, такого как структура, функция или модуль</li>
              </ul>

              <p>В этой главе мы рассмотрим все эти функции, обсудим как они взаимодействуют и объясним, как использовать их для управления областью видимости. К концу у вас должно появиться солидное понимание модульной системы и умение работать с областями видимости на уровне профессионала!</p>




              <br><hr><br>
              <h1 id="result">Обработка ошибок</h1>
              <p>Возникновение ошибок в ходе выполнения программ — это суровая реальность в жизни программного обеспечения, поэтому Rust имеет ряд функций для обработки ситуаций, в которых что-то идёт не так. Во многих случаях Rust требует, чтобы вы признали возможность ошибки и предприняли некоторые действия, прежде чем ваш код будет скомпилирован. Это требование делает вашу программу более надёжной, гарантируя, что вы обнаружите ошибки и обработаете их надлежащим образом, прежде чем развернёте свой код в производственной среде!</p>

              <p>В Rust ошибки группируются на две основные категории: исправимые (recoverable) и неисправимые (unrecoverable). В случае исправимой ошибки, такой как файл не найден, мы, скорее всего, просто хотим сообщить о проблеме пользователю и повторить операцию. Неисправимые ошибки всегда являются симптомами дефектов в коде, например, попытка доступа к ячейке за пределами границ массива, и поэтому мы хотим немедленно остановить программу.</p>

              <p>Большинство языков не различают эти два вида ошибок и обрабатывают оба вида одинаково, используя такие механизмы, как исключения. В Rust нет исключений. Вместо этого он имеет тип Result&lt;T, E&gt; для обрабатываемых (исправимых) ошибок и макрос panic!, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку. Сначала эта глава расскажет про вызов panic!, а потом расскажет о возврате значений Result&lt;T, E&gt;. Кроме того, мы рассмотрим, что нужно учитывать при принятии решения о том, следует ли попытаться исправить ошибку или остановить выполнение.</p>


              <br><br><hr><br><br>
              <h1> Ссылки в карте </h1>
              <map name="infographic">
                <area shape="poly" coords="130,147,200,107,254,219,130,228" href="https://developer.mozilla.org/docs/Web/HTML" target="_blank" alt="HTML"/>
                <area shape="poly" coords="130,147,130,228,6,219,59,107" href="https://developer.mozilla.org/docs/Web/CSS" target="_blank" alt="CSS"/>
                <area shape="poly" coords="130,147,200,107,130,4,59,107" href="https://developer.mozilla.org/docs/Web/JavaScript" target="_blank" alt="JavaScript"/>
              </map>
              <img usemap="#infographic" src="https://interactive-examples.mdn.mozilla.net/media/examples/mdn-info2.png" alt="MDN infographic" height="230"/>


              <br><br><hr><br><br>
              <h1>Подписаться на рассылку</h1>
              <form>
                <label>Адрес: </label><input type="text" name="adres"><br>
                <label>Пароль: </label><input type="password" name="parol"><br>
                <label>Зона текста: </label><textarea name="tekst"></textarea><br>
                <label>Кнопка: </label><button name="knopka">Подтвердить</button><br>
                <label>Частота рассылки: </label>
                <input type="radio" name="chastota" value="nedelya"><label>Раз в неделю.</label>
                <input type="radio" name="chastota" value="mesyac"><label>Раз в месяц.</label><br>
                <label>Тип рассылки: </label>
                <input type="checkbox" name="novosti"><label>Новости.</label>
                <input type="checkbox" name="obnovleniya"><label>Обновления.</label>
                <input type="checkbox" name="recommendacii"><label>Рекоммендации.</label><br>
                <label>Невидимый ввод: </label><input type="hidden" name="nevidimiy"><br>
                <label>Оценка: </label>
                <select name="ocenka">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select><br>
                <label>Подтверждение: </label><input type="image" src="knopka.png" height=40><br>
                <label>Загрузка файла: </label><input type="file" name="file"><br>
                <label>Электронная почта: </label><input type="email" name="pochta"><br>
                <label>Ссылка на почту: </label><input type="url" name="ssilka"><br>
                <label>Цвет: </label><input type="color" name="tsvet"><br>
                <label>Число: </label><input type="number" name="chislo"><br>
                <label>Ползунок: </label><input type="range" name="polzunok"><br>
                <label>Дата регистрации: </label><input type="date" name="data"><br>
                <label>Время регистрации: </label><input type="datetime-local" name="vremya"><br>
                <label>Поиск: </label><input type="search" name="poisk"><br>
                <label>Номер телефона: </label><input type="tel" name="telefon">
              </form>
          </div>
          
        </div>
        
      </div>
    </div>
    
    <div class="footer bg-secondary-subtle p-3">
      <div class="container-sm">
        Github: <a href="https://github.com/egorkasprigorca/">https://github.com/egorkasprigorca/</a>
      </div>
      <div class="container-sm">
        Github: <a href="https://github.com/rolewj.">https://github.com/rolewj</a>
      </div>
    </div>
  </body>
</html>
